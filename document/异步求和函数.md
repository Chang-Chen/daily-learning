### 异步求和函数-串行

```js

/**
 * 模拟异步加载的函数
 * @param a
 * @param b
 * @return {Promise<unknown>}
 */
function asyncSum(a, b) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(a + b);
        }, 1000);
    });
}

/**
 * 异步求和函数
 * @param sums 需要求和的数据源
 * @return {Promise<*>|*|number}
 */
function sums(sums) {
    if (sums.length === 0) return 0;
    if (sums.length === 1) return sums[0];
    if (sums.length === 2) return asyncSum(...sums);

    let promise = asyncSum(...sums.slice(0, 2));
    for (let i = 2; i < sums.length; i++) {
        const num = sums[i];
        promise = promise.then(sum => asyncSum(sum, num))
    }

    return promise;
}

console.time('计算时间');
sums([1, 2, 3, 4, 5, 6, 7, 8]).then(res => {
    console.timeEnd('计算时间');
    console.log('res ===>', res);
})
```

### 异步求和函数-并行

```js
/**
 * 模拟异步加载的函数
 * @param a
 * @param b
 * @return {Promise<unknown>}
 */
function asyncSum(a, b) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(a + b);
        }, 1000);
    });
}

/**
 * 异步求和函数
 * @param numbers 需要求和的数据源
 * @return {Promise<void>|Promise<Awaited<*>>|Promise<Awaited<unknown>>|Promise<Awaited<number>>|Promise<unknown>}
 */
function sums(numbers) {
    if (numbers.length === 0) return Promise.resolve(0);
    if (numbers.length === 1) return Promise.resolve(numbers[0]);
    if (numbers.length === 2) return asyncSum(numbers[0], numbers[1]);

    return new Promise(resolve => {
        const mid = Math.floor(numbers.length / 2);
        const left = numbers.slice(0, mid);
        const right = numbers.slice(mid);

        // console.log('left, right', left, right);

        Promise.all([
            sums(left),
            sums(right)
        ]).then(([leftSum, rightSum]) => {
            asyncSum(leftSum, rightSum).then(resolve);
        });
    });
}

console.time('计算时间');
sums([1, 2, 3, 4, 5, 6, 7]).then(res => {
    console.timeEnd('计算时间');
    console.log('res ===>', res);
})
```